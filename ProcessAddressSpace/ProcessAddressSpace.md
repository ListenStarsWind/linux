[TOC]

# `ProcessAddressSpace`【进程地址空间】

## `introduction`【引子】

我们以前或多或少都见过这种图：

![image-20241024094911429](C:\Users\21066\Desktop\202410240949554.png)

这张图展示了计算机程序在内存中的大致布局，描述了它们之间位置的相互关系，而且说明了栈区和堆区的增长方向，下面我们就用代码体验一下。

```cpp
#include<stdio.h>
#include<stdlib.h>

int j = 0;
int i;


int main()
{
	void* space1 = malloc(sizeof(char) * 10);
	void* space2 = malloc(sizeof(char) * 10);
	void* space3 = malloc(sizeof(char) * 10);

	// 局部变量指针指向常量字符串的首字母
	const char* str = "hello world";

	int a = 0;
	int b = 0;
	int c = 0;

	// main函数位于代码区中
	printf("main:address->%p\n", main);
	printf("'h':daaress->%p\n", str);
	printf("j:address->%p\n", &j);
	printf("i:address->%p\n", &i);
	printf("spqce1:address->%p\n", space1);
	printf("spqce2:address->%p\n", space2);
	printf("spqce3:address->%p\n", space3);
	printf("str:address->%p\n", &str);
	printf("a:address->%p\n", &a);
	printf("b:address->%p\n", &b);
	printf("c:address->%p\n", &c);

	return 0;
}
```

```shell
[wind@starry-sky Debug]$ make clean ; make ; make run
main:address->0x40059d
'h':daaress->0x400780
j:address->0x601040
i:address->0x601044
spqce1:address->0x1ca7c20
spqce2:address->0x1ca7c40
spqce3:address->0x1ca7c60
str:address->0x7ffc8e9ea8b0
a:address->0x7ffc8e9ea8ac
b:address->0x7ffc8e9ea8a8
c:address->0x7ffc8e9ea8a4
[wind@starry-sky Debug]$
```

注意，编译器会依据变量的具体位置进行优化，这种优化虽然对于程序的运行是有利的，但会影响我们的学习逻辑，所以如果你在亲自实验的时候发现地址不是从低到高的，那不是因为上面的图有问题，而是编译器过度优化了（对于学习逻辑来说）。

我们看到，`main`函数位于代码区，在众多打印内容中，地址是最低的；常量字符串"hello world"的首字母'h'地址是第二低的，然后是已初始化全局变量和未初始化全局变量，堆区向高地址处增长，栈区向低地址处增长，并且，堆区地址比栈区低。

接下来我们试试多进程的

```cpp
#include<stdio.h>
#include<stdlib.h>
#include <unistd.h>

int main()
{
	int val = 6;
	int cir = 6;
	pid_t id = fork();
	if (id == 0)
	{
		while (1)
		{
			printf("I am child. pid->%d ppid->%d\n", getpid(), getppid());
			printf("val:%d val->%p\n", val, &val);
			printf("===================================\n");
			sleep(1);
			cir--;
			if (cir == 0)
				val = 8;
		}
	}
	else
	{
		while (1)
		{
			// 不考虑错误，默认成功
			printf("I am parent. pid->%d ppid->%d\n", getpid(), getppid());
			printf("val:%d val->%p\n", val, &val);
			printf("===================================\n");
			sleep(1);
		}
	}
	return 0;
}
```

我们知道，如果子进程不写数据，则父子进程共用数据，若子进程修改数据，则会发生写时拷贝，生成一份的新的副本供子进程修改。

```shell
[wind@starry-sky Debug]$ make clean ; make ; make run
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:6 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:6 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:6 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:6 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:6 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:6 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
I am parent. pid->16288 ppid->16287
val:6 val->0x7fffc67fefe4
===================================
I am child. pid->16289 ppid->16288
val:8 val->0x7fffc67fefe4
===================================
^Cmake: *** [run] Interrupt

[wind@starry-sky Debug]$
```

然后我们发现一个非常奇怪的现象：在发生写时拷贝后，副本和母本应该是两个不同的变量，但按照程序的运行内容来看，它们居然拥有相同的地址。

这意味着程序打印的地址不是真正的物理地址，而是一种虚拟地址，有的也称线性地址。

而我们之前写的C/C++程序中所用到的地址，都不是物理地址，而是虚拟地址，物理地址具有唯一性，它不可能同时拥有两个值。

## `Main Framework`【主线】

考虑到进程地址空间是个较为复杂的概念。所以我们将会分为三个阶段进行学习。

- 第一阶段：从进程角度建立框架

  我们首先从进程角度入手，构建一个关于进程地址空间的总体框架，形成清晰的学习主线。随后再围绕这条主线深入探索各种细节，逐步加深对进程地址空间的理解。

- 第二阶段：基础I/O和库

  在初步框架的基础上，继续学习进程在I/O操作及动静态库使用中的内存地址分配和管理。

- 第三阶段：线程角度深入

  最后从线程角度切入，分析进程地址空间在多线程环境下的表现及变化。

分段式的学习方式能帮助我们逐步建立从宏观到微观的理解，进而达到系统性的掌握。

今天的内容属于第一阶段，目标是为整体思路建立基本的框架，因此我称之为“主线”。本阶段主要以概念讲解为主，具体的实际操作将在接下来的课程中详细说明。

之前我们提到，进程可以具体分为两部分：一是内核中用于描述进程属性的 `struct task_struct` 结构体，二是进程运行所需的代码和数据。不过，这种说法只是为了降低学习门槛、简化思路，并不完全准确。现在，我们来补充这一点：除了这两部分外，进程还包含一个称为**进程地址空间**的数据结构，如下图所示：

![image-20241026114312196](C:\Users\21066\Desktop\202410261143278.png)

为简化学习过程，我们以32位操作系统为讨论对象，因此图中的内存大小为 2^32字节，即4GB。在C/C++程序中，所有地址都是基于进程地址空间的。但我们通过【引子】中的例子认识到，这个进程地址空间并不是实际的物理地址，而是一种虚拟地址，也称为线性地址，其中“线性”意味着地址是连续的。

数据实际存储在物理内存中，为了在虚拟地址和物理内存之间建立联系，我们引入一个称为“页表”的数据结构。为了简化理解，当前我们可以把页表看作一张映射表，一侧是虚拟地址，另一侧是物理地址。当程序需要访问虚拟地址中的数据时，就将该虚拟地址交给页表，页表即可返回对应的物理地址，从而定位到实际的数据存储位置。

![无标题](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410261214255.png)

当父进程创建子进程时，内核会基于父进程的模板，为子进程创建一个几乎相同的 `struct task_struct` 结构体，同时也为子进程创建对应的进程地址空间和页表。刚开始时，父子进程的进程地址空间与页表中的映射关系是完全相同的，即页表中的虚拟地址和物理地址的映射完全一致。因此，父子进程共享相同的物理内存中的代码和数据。

当子进程需要写入某个数据时，系统会以该数据为模板，在物理内存中创建一个副本存放到其他位置，并在页表中更新该数据的物理地址映射，而虚拟地址保持不变。这是因为程序中使用的地址都是虚拟地址，不能随意改变。这一过程就是**写时拷贝**的本质。

这也解答了【引子】中的问题：为什么同一个地址的数据会有不同的值。这里的“地址”并非真实的物理地址，而是虚拟地址。

-----------------------------

之前我们说过，为了让计算机各个部分相互联系，必须有一种称为“总线”的机制。在32位计算机中，存在32位的地址和数据总线。CPU与内存之间的连接称为系统总线，而内存与输入输出设备之间的连接称为IO总线，这些总线实现了数据在不同组件之间的流通。

计算机的二进制本质与数据传输密切相关。从硬件层面看，计算机只识别高低电平信号。32位地址总线中的每根线有两种状态（低电平和高电平），因此能够表示2^32种可能。这意味着CPU最多能寻址2^32字节的内存，即4GB。当CPU通过地址总线发送地址时，内存根据这个地址选取对应的数据，随后CPU进行读取和访问。

地址总线的排列组合范围为[0, 2^32]，即为地址空间。地址空间描述了理论上的最大寻址范围。

----------------

接下来讲一个故事。

小明和小张是幼儿园的两位小朋友。他们共用一张桌子，这张桌子长100cm，这样的话，小明和小张的可被使用空间范围就是[0, 100]。小明没啥边界感，有时没事就去小张的范围，小张就受不了，在桌子上化了一根线：我们约法三章，线左边的部分是你的地盘，右边是我的地盘，你要再越界，我就打你。

![image-20241026132356686](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410261323741.png)

用C怎么描述一下这件事呢？

```c
struct area
{
  int start;
  int end;
};

struct destop_area // 约定1到100
{
   struct area xiaoming;
   struct area xiaozhang;
};

struct destop_area line_area = {{1, 50}, {51, 100}}
```

有一天，小明又把手伸到小张那里，小张多次警告之后，就向小明开打了，结果小明没打过小张，为了给小张一点教训，小张把线往左边移了10cm，并告诉小明，从现在开始，如果小明再越界，就再把线左移10cm。

![image-20241026134239754](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410261342794.png)

这件事从C可以这样描述：

```c
line_area.xiaoming.end-=10;
line_area.xiaozhang.start-=10;
```

空间区域的调整，其实就是对结构体成员的大小进行修改。

----------------------------

地址进程空间是用来描述范围的，它在内核中的本质就是一个结构体变量，在这个变量的成员中，可以看到其对进程地址空间的种种区域划分，代码区的起始地址，全局变量的起始地址，栈区堆区常量字符串的起始地址等。不同区域的划分，有助于明确数据权限，有些数据只能读，有些数据即可读也可写，有些数据的生命周期和栈相同，那对应的栈帧释放之后，这些数据也会释放，虚拟内存中的释放对应着相应物理内存的释放，便能把那些已经不需要的数据删除，为接下来需要的数据留下空间，节约内存，提高效率。有些数据生命周期与进程生命周期相同，如果不主动释放，就会一直存在，便于不同函数栈帧对其的访问，一言以蔽之，所谓的区域划分本质上还是为了更好的管理内存资源。

既然要管理，就需要先组织，再描述。进程地址空间在内核中的具象化类型就是`struct mm_struct`。在Linux内核代码的`/include/linux`文件夹下可以看到它的定义。

![image-20241026152505576](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410261525162.png)

```c
struct mm_struct{
    long code_start;
    long code_end;
    
    long readonly_start;
    long readonly_end;
    
    long init_start;
    long init_end;
    
    long uninit_start,uninit_end;
    long heap_start,heap_end;
    long satck_start,stack_end;
};
```

顺手看看`struct task_struct`

![image-20241026153426991](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410261534561.png)

描述了进程地址空间的地址

![image-20241026153652915](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410261536481.png)

---------------------

接下来我们再讲一个故事

有个大富翁，名下10亿美金资产。他名下有四个私生子，我们就称为ABCD吧，ABC都是儿子，D是女儿。既然是私生子，所以ABCD都不知道对方的存在。A是个工厂小老板，一天，大富翁对A说，“儿子呀，你好好办你的工厂，等我老了，我把我的10亿家产给你。”  B是一个准博士，大富翁对B说：“儿子呀，你好好学，等我老了就把我名下10亿家产给你”。C学习不太好，早早进社会了。富翁就对C说：“儿子呀，等我老了，就把我10亿家产都给你”。D是小女儿，还上小学，富翁对D说：“宝贝女儿，学校有人欺负你就跟老爸讲，等我老了，就把10亿家产给你”。这样，由于ABCD都不知对方存在，所以都认为自己最后会拿到10亿。A工厂流转资金不够了，和富翁一说，5万美金就打过去了；B课题预算不够了，和富翁一说，3万美金就打过去了；C找不到工作，身上钱不够了，和富翁一说，5千美金就过去了；D过生日，富翁就买个大蛋糕漂亮衣服送过去了。ABCD对于钱有各种级别的需求，但这些钱对富翁来说，都是小钱，只要孩子们开口，只要不狮子大张口，富翁都会把钱打过去。即使有哪个儿子说要10亿，富翁也最多骂两句，给个小几万安抚一下或者干脆不给。对于那个儿子来说，他仍然认为最后10亿，10亿到手只是时间问题。

操作系统就是这个大富翁，他的私生子就是各个进程，进程各自独立，只关心自己的事就行了。操作系统为进程们画了一个名为“进程地址空间”的大饼，让进程产生一种错觉，觉得内存资源都是自己的。

-----------------------------------

存在银行里的钱，并不是一直放在金库里，而是被银行用来进行其它金融活动，比如放贷投资。进程对于内存的索取，在系统看来，一般只是洒洒水，就算要求过度，系统也只会拒绝这个进程的需求。

-------------------

每个进程都有自己独立的地址空间，它们对内存的理解方式基本相同，都遵循进程地址空间的分布图。这样做便于操作系统统一管理不同程序的内存，不论是用C/C++、Java/Python还是Go甚至汇编机器码编写的程序，它们对内存的概念都是一致的。进程无需关注物理内存的细节，只需管理好虚拟内存即可。

从虚拟内存的角度看，进程中的数据结构是连续的，不会出现数据在不同位置分散的情况，比如一个`int`的四个字节始终是连续的。然而，从物理内存的角度来看，这些数据可能并不连续，而是分布在不同的物理地址上。这种“碎片化”的分布有助于提高物理内存的利用率，正如一个容器中装球，球越小越能填满空隙，提升了空间利用率。

进程访问数据时，必须通过虚拟内存和页表的配合。页表作为中间层，为数据的权限控制提供了可能。物理内存本身不具备读写权限的概念，只要状态正常，物理内存上的数据既可读也可写。有了页表后，系统可以根据进程请求的虚拟地址来判断数据的权限。例如，对于只读数据，当进程发出写请求时，系统会在页表处拦截该请求，避免请求进一步触及物理内存，从而实现数据保护。

这就是进程地址空间的三大好处，或者说目的。

--------------------

数据的权限控制是从软件层面实现的，而不是光靠语言的语法，比如

```shell
[wind@starry-sky test1]$ ls
test.c
[wind@starry-sky test1]$ cat test.c
//Privilege denial at the system level
//系统层面的权限拦截

int main()
{
  char* str = "hello world";
  *str = 'H';
  return 0;
}
[wind@starry-sky test1]$ gcc test.c
[wind@starry-sky test1]$ ls
a.out  test.c
[wind@starry-sky test1]$ ./a.out
Segmentation fault
[wind@starry-sky test1]$
```

编译器能编译通过，但只要一运行就崩溃。这也体现了系统对非法数据写入的态度——强行终止该进程。如果在`char* str = "hello world";`前加个`const`就是语法层面的拦截，编译器这关就通不过。

CPU中有一个名为`cr3`的控制级别的寄存器，用来描述当前被CPU执行进程的页表地址，由于页表本身就描述着虚拟地址和物理地址的映射关系，所以它使用的地址真的是物理地址，如果页表也使用虚拟地址的话，系统就找不到物理层面的页表数据。CPU中寄存器的种种信息都属于进程的上下文，当进程时间片用尽之后，系统就会把这些上下文保存在`struct task_struct`这个`PCB`对象中，以便于进程下次运行快速回到上次中断的状态，当进程被CPU执行时，CPU会先从`PCB`中读取进程上下文信息然后加载到自己的寄存器上面，这样，`cr3`中就有了页表的地址，CPU就可以通过这个地址找到该进程对应的页表。

页表也是一种数据结构，除了描述了虚拟地址和物理地址的映射关系，还描述了这些地址的权限和归属。

![无标题](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410261742384.png)

`*str = 'H'`尝试对常量字符串`hello world`中的首字母`h`改为`H`，当进程发出这个请求时，CPU就会通过`cr3`找到页表，发现它的物理地址是`0x12345`，接着系统发现这个地址是只读的，而这个请求却想写入，于是系统就会终止CPU的进一步操作，不让其在物理内存上进行操作，接着系统会以进程发出危险请求为由强行终止该进程。

----------------------

操作系统为了解决资源，不会把程序的数据一次性加载到内存中，而是采用“惰性加载”的策略。所谓“惰性加载”就是进程真正要使用数据的时候系统才会把进程需要的数据加载到内存中。一个软件，运行可能总共需要500MB，系统可能先给进程加载几十KB的数据，代码也只给一部分，先让进程跑起来，其它数据进程催了系统再加载。这些未被加载的数据只有虚拟地址，而无物理地址，同时，页表中还有一个字段或者说成员，它描述了这个虚拟地址的数据是否被加载到内存中，即上图中的归属，注意，这里的归属是我自己的叫法，它的官方或者专业化称呼为**“有效位”（Valid Bit）**或**“存在位”（Present Bit）**。我叫它归属是因为它描述了数据的位置，如果数据已经被加载到内存中，则这个字段为1，如果这个字段为0，则表明该处虚拟地址的数据被没有加载到内存中，此时就要从输入输出设备中进行读取，典型的来说，就是硬盘。

如果某处虚拟地址的数据需要被访问，系统会依据“有效位”判断数据是否在内存中，如果在，就通过对应的地址映射表来访问，如果不在，这个进程就会进入缺页中断状态，系统会暂停该进程的继续执行，换言之，这个进程进入了阻塞状态，等到系统把需要的数据加载到内存中，进程才会重新返回到运行队列，然后CPU重新获取该进程的上下文信息，比如页表，之后重新建立虚拟-物理地址映射关系进而继续运行该进程。

写时拷贝其实是一种特殊的缺页中断，有效位并不是简简单单的1或者0，除此之外，它可能包含了一些额外信息，比如，我们之前提到过，子进程刚开始创建时会以父进程为模版拷贝一份与父进程虚拟-物理映射关系以及权限完全一样的页表，此时的权限似乎理解成能力更加合理，对于子进程来说，某个变量的权限是可读可写的，但当子进程真的尝试写数据时，就会通过某种机制（可能让有效位置0）自动触发缺页中断，与一般的缺页中断不同的是，这次系统会从父进程的对应数据那里，而不是外部设备那里读取数据，从而形成一份副本供子进程修改。

具体怎么把数据加载到物理内存中，又加载多少，加载到何处，是内存管理的内容，是我们日后学习的内容。

## 后日谈

引子里我们没说命令行参数是吧下面我们来演示一下：

```c
#include<stdio.h>
#include<stdlib.h>

int j = 0;
int i;


int main(int argc, char* argv[], char* env[])
{
	void* space1 = malloc(sizeof(char) * 10);
	void* space2 = malloc(sizeof(char) * 10);
	void* space3 = malloc(sizeof(char) * 10);

	// 局部变量指针指向常量字符串的首字母
	const char* str = "hello world";

	int a = 0;
	int b = 0;
	int c = 0;

	// main函数位于代码区中
	printf("main:address->%p\n", main);
	printf("'h':daaress->%p\n", str);
	printf("j:address->%p\n", &j);
	printf("i:address->%p\n", &i);
	printf("spqce1:address->%p\n", space1);
	printf("spqce2:address->%p\n", space2);
	printf("spqce3:address->%p\n", space3);
	printf("str:address->%p\n", &str);
	printf("a:address->%p\n", &a);
	printf("b:address->%p\n", &b);
	printf("c:address->%p\n", &c);
	
	int i = 0;
	for( ; argv[i]; i++)
		printf("argv[%d]:%p\n", i, argv[i]);

	for(i = 0; env[i]; i++)
		printf("env[%d]:%p\n", i, env[i]);

	return 0;
}
```

```shell
[wind@starry ~/code/ProcessAddressSpace]$ ./out -a -b -c
main:address->0x649bc9ee1189
'h':daaress->0x649bc9ee2004
j:address->0x649bc9ee4014
i:address->0x649bc9ee4018
spqce1:address->0x649bc9fb12a0
spqce2:address->0x649bc9fb12c0
spqce3:address->0x649bc9fb12e0
str:address->0x7ffd569f2678
a:address->0x7ffd569f2668
b:address->0x7ffd569f266c
c:address->0x7ffd569f2670
argv[0]:0x7ffd569f423e
argv[1]:0x7ffd569f4244
argv[2]:0x7ffd569f4247
argv[3]:0x7ffd569f424a
env[0]:0x7ffd569f424d
env[1]:0x7ffd569f425d
env[2]:0x7ffd569f4271
env[3]:0x7ffd569f428d
env[4]:0x7ffd569f42b5
env[5]:0x7ffd569f42c2
env[6]:0x7ffd569f42d7
env[7]:0x7ffd569f4351
env[8]:0x7ffd569f4361
env[9]:0x7ffd569f4372
env[10]:0x7ffd569f4a8b
env[11]:0x7ffd569f4aab
env[12]:0x7ffd569f4b33
env[13]:0x7ffd569f4b67
env[14]:0x7ffd569f4b86
env[15]:0x7ffd569f4ba8
env[16]:0x7ffd569f4bbf
env[17]:0x7ffd569f4bd3
env[18]:0x7ffd569f4bf3
env[19]:0x7ffd569f4bfd
env[20]:0x7ffd569f4c3d
env[21]:0x7ffd569f4c45
env[22]:0x7ffd569f4c58
env[23]:0x7ffd569f4c77
env[24]:0x7ffd569f4c9b
env[25]:0x7ffd569f4cbd
env[26]:0x7ffd569f4cec
env[27]:0x7ffd569f4d85
env[28]:0x7ffd569f4dd7
env[29]:0x7ffd569f4e53
env[30]:0x7ffd569f4f27
env[31]:0x7ffd569f4f5d
env[32]:0x7ffd569f4f7e
env[33]:0x7ffd569f4f92
env[34]:0x7ffd569f4fea
[wind@starry ~/code/ProcessAddressSpace]$
```

我们在上面的内容里选择性的忽略了进程地址空间的内核空间，内核空间顾名思义就是内核直接管理的，比如进程控制块，页表，进程地址空间等，由于它们是直接用物理地址的，所以映射关系比较简单，时候到了会细说的。

之前我们说写时拷贝的时候，总是说，子进程要写入数据时会发生写时拷贝，其实，这种说法并不准确。实际上，当`fork`的核心逻辑已经创建出子进程后，父子进程的所有数据权限都会被设置成一种特殊的只读状态，此时的这种只读状态更像是权限，而以往的那种权限更像是能力，权限规定可以做什么，能力则规定到底能做什么。对于某个可读可写的局部变量来说，它的能力是可读也可被写，而现在的权限被设置成只读，当父子进程中的某一个进程对这个变量进行写入操作时，都会触发写时拷贝，系统发现，这个变量具有可读可写的能力，但现在权限却是只读，这种冲突就会引发缺页中断，与一般缺页中断不同，这次系统不是从硬盘或者其他外设里读数据，而是从内存中读数据，系统会先依据虚拟地址找到真正的物理地址，然后把这个变量拷贝一个副本，放在物理内存的其他地方，然后，修正尝试写入数据进程的页表，修改该变量虚拟地址对应的物理地址，建立新的映射关系，并把父子进程的相关地址由特殊只读全部改为可读可写，此时父子进程就不共用同一个变量了。

# End
