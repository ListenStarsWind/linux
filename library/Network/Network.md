# 网络

## 网络基础 Ⅰ

所谓网络通信, 其实就是把对方需要的数据放在一个特定形式的容器里, 然后依据一些规定, 在网络之间拷贝过来拷贝过去, 最终对方收到对象后, 再把数据取出来进行处理. 在这个过程中, 容器的形式是怎么样的, 具体是怎么传的, 收到之后又怎么解析, 都不是乱来的, 而是遵循着大家都承认的一个约定, 我们把这种约定, 称之为"协议".

如果把网络极简抽象, 每个主机或者说网络节点就是一个个文件, 这些文件一方面可以存储数据, 另一方面, 可以把自己身上的数据写到其它文件中, 在写来写去的过程中, 数据就完成了传送,   这些文件集群没有明显的中心, 或者说每个文件都是中心, 每个文件看上去似乎都是相同的, 它们都需要面对一些问题, 比如我该如何解释从别的文件里写过来的数据, 如果我要继续往下传, 我该传给谁, 知道传给谁后, 如果传送失败该怎么办.... 协议都规定了这些问题的解决方式, 比如, 数据链路层协议告诉你这个数据下一次该传给谁, 文件之间如何区分定位, 则是ip协议负责的内容, 数据传到中间丢了怎么办, 这是 tcp 协议发挥作用的地方, 接收到的数据该如何解释, 则是fttp, fttps, http... 它们的事.

为什么有这么多问题? 因为文件太多了, 情况太多了, 链路太长了.

我们可以把协议看做抽象类, 它是一系列声明, 告诉你, 如果要传输数据, 你应该要干什么, 而具体的协议实现则是继承这个抽象类, 提供了接口的实现方式, 而每个数据包, 就是通过该类实例化的对象, 存储数据. 

## 协议的分层

网络是个很复杂的系统, 对于这种系统来说, 我们往往采用分层的概念, 其实在之前的线程学习阶段中, 我们就无意中写出了分层的代码.

让我们回顾一下.

我们在写生产消费者模型的时候, 为了让程序的运行效果更加明显, 我们总喜欢往里面加些信息的打印.   最开始, 我们把打印放到锁外, 但由于所有的线程用的都是同一个屏幕, 所以经常会出现打印混乱的情况, 甚至, 有些打印虽然不混乱, 但内容具有误导性, 在实际运行中, 实际上是生产者先运行, 然后消费者再运行, 但在打印的时候, 消费者却率先运行执行了打印指令, 先打印了消费数据的信息, 然后再是生产者打印生产数据的信息.         为了解决类似问题, 同时考虑到多线程程序设计时的原则:  临界资源应该尽可能放到一块进行访问,   所以我们设计了一个数据守卫层,   把一个数据放入容器必须要经过数据守卫层的插入接口, 而将数据取出容器也必须经过数据守卫层的取出接口, 生产者和消费者在经过守卫层的插入取出接口时, 将会执行由用户提供的回调函数: 打印相关的消息.  单从最外层的线程行为函数上来看, 完全看不到数据守卫层的痕迹, 数据以什么样的形式进入, 它就会以什么样的形式被取出, 在逻辑上就像是直接相连一样. 稍后我们会在网络中也见到相似的场景, 只不过网络层数更多了.  

![image-20250311121752401](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311121752492.png)

什么是协议, 协议就是一种约定, 在线程行为层, 我们用的都是同一个类型, 生产者生产一个任务, 消费者就能得到一个任务, 它们在逻辑上是相连的, 我们可以完全不考虑其它层的情况, 在容器层, 容器也不在乎生产者生产的是什么任务, 甚至线程行为层换成别的`task`类, 它也无所谓, 同样的, 它也不需要考虑守卫层内部的具体情况, 它们在逻辑上也是相连的, 我往下传了什么对象, 对面的就会收到什么对象, 在逻辑上也是相连的. 对于数据守卫层来说, 它也不在乎上层具体是怎么实现的, 这个容器可以用队列, 也可以用数组, 还可以用其它接口, 我不在乎, 我只需要在收到对象的时候, 顺手执行一下主线程提供的信息打印函数, 给容器层数据的时候再顺手执行一下对应的打印函数即可.

分层的好处, 用行话来说, 就是高内聚低耦合,  高内聚就是各层只负责各自的事, 行为层, 你只需要生产消费数据就行了, 你不需要操心, 数据是怎么传的, 会不会发生数据不一致问题.  容器层也不用管上层用的到底是什么类型, 你只需要在合适的地方上锁, 保证线程安全就行了, 守卫层只负则在数据进入拿出时取出数据执行回调函数就行, 不用担心线程安全, 因为锁是从容器层那里开始上的, 也只能从容器层那里解. 低耦合就是各层之间没有很强的联系, 行为层换任务类了, 无所谓, 下层不需要改代码, 容器层换容器了, 无所谓, 上层该插入就插入, 该取出就取出.  守卫层增加了功能, 对于其它层来说也没有影响.  各层改变的影响只会在层内传播, 不会跨层传播.  这样就便于维护和优化.

 下面我们回到网络.

对于网络来说, 更是要分层.  两个用户, 张三和李四, 你们在进行网络通信时, 你也不需要考虑什么网络问题, 你们要关心的, 就是张三说的话李四能听懂, 李四说的话张三也能听懂, 这就够了, 我们在用户层要遵循人类语言协议, 要说大家都能听懂的话, 在感觉上, 底层的技术细节被隐藏了, 张三在电脑上输入的是什么话, 李四收到的就是什么, 反之亦然, 张三和李四就像是在直接沟通, 他们在逻辑上是连为一体的.

![image-20250311130324127](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311130324201.png)

我们在语言层用的是汉语, 要遵循汉语的协议,  设备层用的是座机.也要准许相应的座机协议. 

现在我们换成无线电, 那该说什么话, 就说什么话, 不需要在乎设备层的更换.

![image-20250311130624544](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311130624598.png)

如果改成说英语, 那设备层也是该怎么样就怎么样, 不需要因为语言的改变而做一些特殊操作

![image-20250311130748218](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311130748269.png)

 网络要分层有内因也有外因.   从外因上说, 是因为分层天然能产生高内聚低耦合, 这是一种好的程序设计思路. 从内因来说, 网络通信中额问题天然是分层的, 首先要保证每个主机能相互连接起来, 这样一个主机到另一个主机才有通信的可能, 打个比方, 张三遭遇了海难, 到了一个孤岛上面, 那个孤岛旁边根本没有航线, 李四想要给张三一些东西根本无从谈起.  现在各个主机相连了, 这就确保, 最起码是存在一条路径, 能把主机`A`和主机`B`连起来, 这才有通信的可能.   确保最起码有这样一条路之后, 我们要保证数据在传输过程中, 不会迷路, 每遇到一个路口, 它都知道, 我应该往那条路走, 而不是往那条路走.   如果还是用之前的例子, 那就是要确保运输物资的那条船不要偏离航线.   接着, 张三收到了李四传来的物资, 接下来要解决的问题, 是张三要知道李四发的是什么东西, 知道这个东西该如何解释, 这就是应用层的事, 李四给张三发来一个火箭, 可以张三根本不会用, 那也是白搭.

那具体该如何分层呢?	

国际标准化组织提出了一种被称为"开放式系统互联"`Open Systems Interconnection`, 简称为`OSI`的概念模型., 它把网络从逻辑上分为了7层. 每一层都有相关、相对应的物理设备，比如路由器，交换机;  这个模型在理论上设计的非常好, 它的最大优点是将服务、接口和协议这三个概念明确地区分开来，概念非常清楚, 因此经常出现在教科书上,  已经成为了一种经典模型了.

![image-20250311143430783](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311143431121.png)

但是它分的实在太细了, 所以在日常工程实践中, 我们用的往往另一种简化的模型, 称之为"TCP/IP五层(或四层)模型 "

## TCP/IP模型 

TCP/IP通讯协议采用了5层的层级结构，每一层都呼叫它的下一层所提供的网络来完成自己的需求, 同时为更高层提供对应的服务.

- 物理层: 负责光/电信号的传递方式. 比如现在以太网通用的网线(双绞 线)、早期以太网采用的的同轴电缆(现在主要用于有线电视)、光纤, 现在的wifi无线网使用电磁波等都属于物理层的概念。物理层的能力决定了最大传输速率、传输距离、抗干扰性等. 集线器(Hub)工作在物理层.  
- 数据链路层: 负责设备之间的数据帧的传送和识别. 例如网卡设备的驱动、帧同步(就是说从网线上检测到什么信号算作新帧的开始)、冲突检测(如果检测到冲突就自动重发)、数据差错校验等工作. 有以太网、令牌环网, 无线LAN等标准. 交换机(Switch)工作在数据链路层.  
- 网络层: 负责地址管理和路由选择. 例如在IP协议中, 通过IP地址来标识一台主机, 并通过路由表的方式规划出两台主机之间的数据传输的线路(路由). 路由器(Router)工作在网路层.  
- 传输层: 负责两台主机之间的数据传输. 如传输控制协议 (TCP), 能够确保数据可靠的从源主机发送到目标主机.  
- 应用层: 负责应用程序间沟通，如简单电子邮件传输（SMTP）、文件传输协议（FTP）、网络远程访问协议（Telnet）等. 我们的网络编程主要就是针对应用层.  

![image-20250311144200162](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311144200582.png)

我们一般不操心, 实际上操心也没用, 物理层的事, 所以也有把TCP/IP说成是四层的.表示层和会话层是被归纳为应用层的.

其中, 网络层和传输层被内嵌到系统之中, 它们也是五层里面最重要的两个层, 其中的代表协议就是TCP, IP, 所以这个模型被叫做"TCP/IP模型 ". 有时我们也把这个模型叫做"TCP/IP"协议栈.

物理层负责提供光电信号的基本载体,  链路层让各种设备可以互相连接, 网络层负责为数据流确定传输方向, 传输层负责数据在传输过程的稳定, 应用层负责数据的使用. 

在继续谈网络之前, 先让我们把系统和网络放在一块说说.

![绘图1](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/202410111425950.png)

如图, 这是计算机的分层结构. 

网络的各种层都被内嵌的计算机的对应层中. 比如, 物理层就被内嵌进网卡中, 数据链路层则是网卡驱动的一部分, 图中的系统调用和操作系统可以合称为系统内核, 其中就包含着网络层和传输层的实现, 而剩下的用户部分, 则对应着应用层.

每一次网络通信, 都必须要贯穿整个计算机, 都必须贯穿整个协议栈, 区别只是在于方向不同, 对于发送者, 是由上而下贯穿, 对于接受者, 则是由下而上贯穿, 网络被计算机内化为自身的一部分, 网络通信的本质就是贯穿协议栈的过程.

## 网络传输基本流程

我们先来看张图

![image-20250311163337436](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311163337511.png)

这里要强调的是, 网络的各层都是依托在计算机上的, 不要光看到各种各样的网络层, 更要意识到, 它们背后是计算机的分层结构. 每个竖列都相当于上面我们那张计算机分层图的化简.

我们知道, 想要让任意两台主机通信, 首先要做的就是让相近的主机连接起来, 形成一个局域网. 同一个局域网下的设备, 可以进行直接通信. 比如, 在日常生活中, 我们可能在手机上看到了一部好看的电影, 你想和家人一起看, 但电视上找不到免费的资源, 所以就可以直接把手机的播放内容投屏到电视上, 这样做的前提是, 电视和手机必须连在同一个局域网下.

保障局域网正常运行的协议就是局域网协议, 局域网协议有很多种, 比如以太网, 令牌环网, 无线LAN... 上面图中用的就是以太网, 也是用得最多, 最广泛的局域网协议. 

我们知道, 网络中的每一层都有自己的协议, 而在实际代码中, 我们通过对高层传来的数据上添加额外数据的方式, 落实协议, 这些额外数据, 就被称之为"报头", 在代码中, 它以结构体或者字符串集合的方式呈现, 是对应网络层通信双方都能理解的内容. (我们之前说过, 通信双方的相同网络层在逻辑上都可以认为是直接沟通的), 我们会把一些需要的信息填充到结构体的各个成员或者各个字符串上, 为了方便起见, 我们先姑且认为, 报头都是结构体. 

现在客户想要对服务器发送一份数据, 应用层中就会首先在这份数据上加上应用层协议的报头. 报头和数据就构成了一份报文, 报头中有很多属性 描述了应用层协议的各种信息,  比如, 在下图中, 我们就在报头中加入了应用协议的版本号. 将来, 服务器的应用层会获得同样的一份报文, 会将其进行解包, 获得同样的数据.如果版本号是最新的, 那服务端就按照最新的方式来解释数据, 如果是老版本, 就要用对应的解释方式, 否则就会发生混乱, 造成信息的错误.

![image-20250311173146538](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311173146617.png)

我们说过, 通信必须贯穿协议栈, 所以这份报文将会被传到传输层, 传输层也要加上自己的协议报头. 传输层要保证数据在传输过程中不发生错乱, 所以需要给数据带上序号, 保证数据在传输过程中的有序性.

![image-20250311173840509](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311173840571.png)

网络层也是如此, 要加上对应的报头, 它要为数据的传输指引方向, 所以, 报头内容中含有描述数据传输过程中起始和终点位置的信息.

![image-20250311174410581](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311174410646.png)

接着这份报文会被传到链路层, 链路层亦会在其上加上自己的协议报头.

![image-20250311174628581](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311174628650.png)

我们把左边的过程称之为"数据自顶向下的交付", 这其实是一个不断封装的过程.

在每一层中, 去掉本层协议报头的报文被称之为有效载荷, 比如, 对于应用层, 去掉应用层报头后剩下了`date`, 所以`date`就是对应的有效载荷, 而在传输层里, 去掉传输层报头, 剩下的是应用层报头和`date`, 所以它们两个就是传输层的有效载荷...

之后, 报文就会在以太网中传播, 于是对面服务器的网卡就捕捉到了这条报文. 然后交给了以太网驱动程序, 因为用的是同样的链路层协议, 所以服务器的以太网驱动程序就可以识别出这条报文中哪些是链路层协议, 哪些是有效载荷, 于是它就把报头与有效载荷分离, 把有效载荷传到上一层, 上一层的"IP"协议就也能识别出自己层的报头, 就会让报头和有效载荷分离, 并把有效载荷传到上一层.... 最终, 用户就拿到了这份数据.   将报文中的有效载荷和报头分离就被称之为"解包"

![image-20250311190636381](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311190636443.png)

同层协议的报文都是相同的, 所以在逻辑上就相当于直接相连.  

另外需要注意的是, 同一层协议里有很多中种类, 比如传输层, 除了"TCP"外, 还有"UDP"等其它种类的协议, 所以下一层在往上传有效载荷前还要看准了, 要传到对应的上一层具体协议上.

网络通信的内容就是在不断进行封装和解包的过程.

显而易见, 每个报文在生成之后, 总有要被解包的时候, 所以几乎对于任何一种协议, 都必须有将报头和有效载荷分离的能力,  并且, 为了让之后解包的同层协议知道该把解包后的有效载荷传给上一层中的哪个, 几乎所有的协议, 都要在报头中提供, 决定将自己的有效载荷交付给上一层哪一个协议的能力, 我们把这种能力称为"分用". 这两条是大部分协议的共性, 在将来我们学习具体协议的过程中, 我们就将这两条作为学习的线索, 它们的地位和系中的"先描述, 再组织"相同.

## 以太网通信

在一个局域网中, 为了大家能够相互区分, 每台主机在局域网中, 都要有自己的唯一一个标识. 

我们可以把一个局域网看做一个教室, 局域网中的每个主机都相当于教室中的同学以及老师. 当老师要求张三回答某个问题时, 所有同学都会听到, 但只有张三会进行响应. 这是因为, 大家会对老师说的话进行信息提取, 当发现老师叫的不是自己时, 大家就会把这条消息丢弃, 不进行响应, 而对于张三来说, 他经过信息提取后发现叫的是自己, 所以就会做出响应. 张三回答这个问题, 大家也都能听到, 老师让张三再回答一个问题, 大家都能听到, 但只有张三会再次回答.   这就类似与局域网中的情况, 其中的任何一个主机发出数据, 大家都能收到.

局域网中每个主机的网卡, 都有一串序列, 这就是每台主机在局域网中相互区分的唯一标识符,  称之为"Mac"地址, 当操作系统启动时, 就会读取网卡的"Mac"地址, "Mac"地址在理论上全球唯一, 但在实际上, 只需要同一个局域网下唯一即可.  

![image-20250311195311448](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311195311538.png)

我们假设上图代表的就是一个局域网,. 中间的那条线就是以太网, 图中的方框就是局域网中的主机, 每个主机都有自己的"Mac"地址, 当其中的一台主机发送数时, 链路层协议就会把报头拼接到自己的有效载荷上, 链路层报头就描述了数据的原始Mac地址和目标Mac地址. 之后当它把报文发出去后, 局域网中所有主机的网卡都会捕捉到这条报文

![image-20250311200802566](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311200802619.png)

如图H1向局域网中发出了一条报文, 目标是H6.

局域网中的所有主机网卡都会捕捉到这条报文, 之后这些主机就会对接收到的报文进行解包, 解包下来的报头会被分析, 其它主机链路层发现, 这条报文不是发给自己的, 于是它们就会把有效负载舍弃, 而不传给更高层. 所以对于其它主机的上层来说, 它就像从来没收到过这个报文. 而对于H6来说, 它的链路层发现这就是给自己的报文, 而且是从H1那里来的, 所以它就会把解包后的有效载荷传到更高层. 

当局域网中的多台主机同时发送报文, 就类似于教室里的同学在大声吵闹, 数据就会相互干扰, 从而丢失了原有的信息, 我们把这种情况, 称之为, "数据碰撞".而在实际生活中, 常见的体现就是上午10点多, 你请假了, 在宿舍里, 网络情况就会非常好, 因为没几个设备在连着局域网, 而等到晚上, 网络就会变得差一点, 因为局域网中的主机多了, 发生数据碰撞的可能也增加了.

为了应对数据碰撞问题, 链路层就有对应的碰撞避免算法: 其实现其实很简单, 碰撞了, 没关系, 我等个随机数的时长, 再把报文发一遍.  如何知道自己发出的报文发生碰撞了? 这也很简单, 链路层可以尝试捕捉自己发出的报文, 捉不到, 那就相当于发生碰撞, 这和我们上面的比喻也很相似. 教室里很嘈杂, 你是李四, 朝张三说话, 结果连你自己都听不清自己在说什么, 那张三自然更听不清. 

由于局域网中的主机网卡都能捕捉到局域网中的所有报文, 只不过是解包后发现不是自己的, 在链路层丢弃了, 但实际上, 我们也可以通过系统配置链路层, 让其进入所谓的"混杂模式", 混杂模式会将所有捕捉到的报文都进行解包, 即使不是发给自己的, 也把有效载荷发给上一层, 所以, 这就有一定的数据安全问题, 但也不用太过担心, 一般来说, 数据在应用层会被加密, 所以当别人把包解完后, 拿到的仍然是被加密的数据, 所以也不用过于担心. 

在局域网中, 任何时候都只能有一定数目的主机发报文, 当超过该数目时, 就会发生数据碰撞问题,  为了应对这个问题, 一方面, 我们有碰撞避免算法, 另一方面, 我们可以在局域网中添加交换机, 交换机的作用就相当于把局域网分成两个小部分, 就类似与把一个50人的大班拆成25人的两个小班, 分别在两个教室里上课, 这样就能减少数据碰撞的可能. 

![image-20250311204645010](https://md-wind.oss-cn-nanjing.aliyuncs.com/md/20250311204645083.png)

在上图中, 整个局域网被交换机分成了左右两个子部分. 当左边没有发生数据碰撞时, 交换机就会让左边的报文进入右边, 而当左边出现数据碰撞时, 交换机就会拦下错误报文, 不让它的影响进一步扩大. 

我们把网络中所有可能发生数据碰撞的区域称之为碰撞域, 在交换机被接入前, 上图有一个碰撞域, 而当交换机接入后, 就变为了两个相对独立的小碰撞域, 所以交换机的功能就是划分 碰撞域.

虽然局域网中可能经常发生数据碰撞问题, 但还是不要太担心, 你要相信光电的速度, 它不会多低效.

局域网就类似于所有主机的共享资源, 主机之间应该对局域网进行互斥访问, 它的互斥不是靠锁事前预防, 而是随便访问, 出问题再使用防碰撞算法, 主打事后解决.  不过, 有些局域网是有互斥锁这种东西的, 这种局域网我们称之为"令牌环". 

# 完